{"name":"Otter","tagline":"A server that runs your client-side apps","body":"Otter\r\n=====\r\n\r\nA server that runs your client-side apps.\r\n\r\nWait, what?\r\n-----------\r\n\r\nWeb apps are shifting client-side. More and more logic is moving from the server to the client, but this often ends up with your server becoming just a JSON API and a blank index.html which gets filled with content client-side. This sucks for two reasons:\r\n\r\n - It's slow. You have to make at least two round trips to the server before any content is displayed.\r\n - It's invisible to search engines, curl, browsers with JavaScript disabled, etc.\r\n\r\nThe typically solution to this problem is to write code on your server that renders some of what the client would render. This works, but now you're writing everything twice.\r\n\r\nBut what if we could use client-side APIs on the server? What if we could generate pages with the DOM instead of templates? And make HTTP requests with XMLHTTPRequest? This would mean we could run client-side code on the server without modification.\r\n\r\nOtter does just that. When a client makes a request to Otter, it loads up your app inside Zombie.js, a Node implementation of the browser APIs. Once the page finishes loading, it renders the DOM to a string and sends it back to the client.\r\n\r\nIf the client supports JavaScript, they can start up the client-side router and it's business as usual. If the client can't run JavaScript, they just see the content like a normal web page.\r\n\r\n### So I have to write my server in JavaScript?\r\n\r\nNope! You don't have to modify your server.\r\n\r\nOtter's a standalone server that runs client-side JavaScript. The app running inside Otter talks to the same thing your browser does. If you've got a Backbone app, it talks to the same server which serves JSON for your models.\r\n\r\n### So I have to write my client-side code with Backbone?\r\n\r\nNope! Unlike other techniques which allow you to run the same code on the server and in the browser, Otter is framework agnostic. It is an implementation of the browser APIs on the server, so almost any code which runs inside the browser will run inside Otter.\r\n\r\n### Is it secure?\r\n\r\nOtter is far more paranoid than a browser so you don't trip up on common client-side vulnerabilities. \r\n\r\nAll code runs inside a sandbox. Node's sandboxes are not perfect, though â€“ you must still make sure you always run trusted code. To help with that, Otter will only allow HTTP requests to the local server by default. If you wish to load data from other domains, you must explicitly allow them.\r\n\r\nInstall\r\n-------\r\n\r\n    $ sudo npm install -g otter\r\n\r\n(Or your preferred way of installing npm packages.)\r\n\r\nGetting started\r\n---------------\r\n\r\nOtter is, at a basic level, an HTTP server. Pointed at a directory, it will serve the files inside it. Only when it is asked to serve a file that doesn't exist does it start doing clever things.\r\n\r\nWhen asked to serve a file that doesn't exist, it will load the file `index.html` and open that up in Zombie.js. When Zombie.js has finished running the page (all Ajax requests have finished, etc), it will send `document.outerHTML` as the HTTP response back to the client.\r\n\r\nTo demonstrate how Otter works, an example app is included in `example/`. It is a simple Twitter client written in Backbone. The first page load runs server-side, then the client instantiates Backbone's router to handle subsequent requests. It uses [backbone-otter](https://github.com/bfirsh/backbone-otter) to handle caching between server and client.\r\n\r\nRun Otter on that directory, allowing requests to `api.twitter.com`:\r\n\r\n    $ otter -a api.twitter.com example/\r\n    Server started on port 8000.\r\n\r\nPoint your browser at [http://localhost:8000](http://localhost:8000).\r\n\r\nUsage\r\n-----\r\n\r\n    $ otter [options] <path>\r\n\r\nOtter is passed a path to a directory which is expected to contain an `index.html` file. It takes these options:\r\n\r\n#### -a `host1,host2`\r\n\r\nA comma-separated list of hosts to allow connections to (e.g. `api.example.com,api.twitter.com`). By default, Otter will not allow connections to be made to any host except itself. If you want to allow Ajax connections to your API, for example, you will need to add it to this list.\r\n\r\n#### -p `port`\r\n\r\nThe port to listen on. Default: 8000\r\n\r\nAPI\r\n---\r\n\r\nOtter provides an API to use inside your apps, exposed as `window.otter` on both the server and the client.\r\n\r\n### `window.otter.isServer`\r\n\r\n`true` or `false`, whether or not the page is running on the server or client.\r\n\r\n### `window.otter.cache`\r\n\r\nAn object that can be used to pass data from the server to the client. You can set values in this object on the server, then when Otter has finished rendering a page, it serialises it to JSON and passes it to the client. It is injected into the top of the page so it is also available as `window.otter.cache`.\r\n\r\n\r\nResuming your app on the client\r\n-------------------------------\r\n\r\nA tricky problem is reinstantiating the app on the client after the app has been run on the server so it can handle user interaction and route future pages. Otter is framework agnostic, so it doesn't prescribe a solution. Though it does provide tools, such as `window.otter.cache` (see [API](#api)) and [backbone-otter](http://github.com/bfirsh/backbone-otter) if you're using Backbone.\r\n\r\nThe brute-force solution is to just reroute the URL, completely rebuilding the page client-side. This isn't as scary as it sounds if you cache the data that was fetched on the server, but the downsides of this are its obvious inefficiency and perhaps some odd side-effects of loading a new copy of the DOM in if the user has already interacted with the initial DOM.\r\n\r\nWe can be smarter, though. We can cache the data fetched server-side and pass it to the client. If we then rebuild a set of models and views attached to the correct DOM elements that the server has generated, we can then efficiently \"boot up\" the application again. In Backbone, this would be a matter of only rendering a view if it hasn't already been rendered by the server. See the included example app for a simple example of how this can be done.\r\n\r\nI am working on some [Backbone tools for Otter](https://github.com/bfirsh/backbone-otter) to make this process easier.\r\n\r\nExtending Otter\r\n---------------\r\n\r\nInstead of running Otter standalone, it can also be extended by using it as part of a Node.js app. See `lib/otter/server.coffee` for the Express app that is used internally. The renderer is available as `require('otter').renderer`.\r\n\r\n\r\nRunning the test suite\r\n----------------------\r\n\r\n    $ npm test\r\n\r\n\r\n\r\n","google":"UA-6774621-4","note":"Don't delete this file! It's used internally to help with page regeneration."}